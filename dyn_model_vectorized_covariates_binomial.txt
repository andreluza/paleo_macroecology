
   
    model {
    
     #############################################################
    #                                                           #
    #                  Biological process                       #
    #                                                           #
    #############################################################
    
    
    # Site Occupancy Dynamics (Priors)
    
   
       for (g in 1:ngen) {
    
	    # intercept
          # gamma
          gamma.d[g] ~ dunif(0,1)
          intercept.gamma[g] <- logit(gamma.d[g])
          
          # phi
          phi.d[g] ~ dunif(0,1)
          intercept.phi[g] <- logit(phi.d[g])
          
          # regression coefficients
          
          # ----------------------
          #     Gamma (origination)
          # ----------------------
          
          # elevation
          beta.gamma.elev[g] ~ dnorm(0, 0.001)#dnorm (mu.int.gamma[g],tau.mu.gamma[g])  
          #mu.int.gamma[g] ~ dnorm(0, 0.001)
          #tau.mu.gamma[g] <- 1/(sigma.int.gamma[g]*sigma.int.gamma[g])
          #sigma.int.gamma[g] ~ dunif(0,10)
          
          # precipitation
          beta.gamma.prec[g] ~ dnorm(0, 0.001)#dnorm (mu.int.gamma.prec[g],tau.mu.gamma.prec[g])  
          #mu.int.gamma.prec[g] ~ dnorm(0, 0.001)
          #tau.mu.gamma.prec[g] <- 1/(sigma.int.gamma.prec[g]*sigma.int.gamma.prec[g])
          #sigma.int.gamma.prec[g] ~ dunif(0,10)
          
          # temperature
          beta.gamma.temp[g] ~ dnorm(0, 0.001)#dnorm (mu.int.gamma.temp[g],tau.mu.gamma.temp[g])  
          #mu.int.gamma.temp[g] ~ dnorm(0, 0.001)
          #tau.mu.gamma.temp[g] <- 1/(sigma.int.gamma.temp[g]*sigma.int.gamma.temp[g])
          #sigma.int.gamma.temp[g] ~ dunif(0,10)
          
          
          # ----------------------
          #     Phi (persistence)
          # ----------------------
          
          # precipitation
          beta.phi.prec[g] ~ dnorm(0, 0.001)#dnorm (mu.int[g],tau.mu[g])  
          #mu.int[g] ~ dnorm(0, 0.001)
          #tau.mu[g] <- 1/(sigma.int[g]*sigma.int[g])
          #sigma.int[g] ~ dunif(0,10)
          
          # temperature
          beta.phi.temp[g] ~ dnorm(0, 0.001)#dnorm (mu.int.temp[g],tau.mu.temp[g])  
          #mu.int.temp[g] ~ dnorm(0, 0.001)
          #tau.mu.temp[g] <- 1/(sigma.int.temp[g]*sigma.int.temp[g])
          #sigma.int.temp[g] ~ dunif(0,10)
          
          
        }
       
       
  
    
        ## set initial conditions
        ## priors for occupancy in time 1
        for (i in 1:nsites) {
        
            for (g in 1:ngen) {
         
              psi1[i,g] ~ dbeta(a,b)
             
            }
         }
    
    # Specify the hyperparameters for the Beta distribution
    a <- 10   # probability of success
    b <- 90   # probability of failures
    
    
    ############      Model       #############
    
    
    for (i in 1:nsites) {
    
      for (g in 1:ngen) {
    
          z[i,1,g]~dbern(psi1[i,g]) # occupancy status initialization
    
              for (t in 2:nint){
            
               ### model dynamic parameters
                logit(gamma[i,t,g]) <-  intercept.gamma[g] + 
                                        beta.gamma.elev[g]*elevation[i,t]+
                                        beta.gamma.prec[g]*precipitation[i,t]+
                                        beta.gamma.temp[g]*temperature[i,t]
        
                logit(phi[i,t,g]) <-  intercept.phi[g] + 
                                      beta.phi.prec[g]*precipitation[i,t]+
                                      beta.phi.temp[g]*temperature[i,t]
        
                # model likelihood
                ### modeling dynamics conditional on previous time realized occurrence z
                muZ[i,t,g] <- z[i,t-1,g] *  phi[i,t,g] + ### if occupied, p of not getting extinct/persist in the next time
                          (1-z[i,t-1,g]) *  gamma[i,t,g] ###  if not occupied, p of originate in the next time
                
                # realized occurrence
		    z[i,t,g] ~ dbern(muZ[i,t,g])
    
        }#t
        
      } #g
    
    }#i
    
    #############################################################
    #                                                           #
    #         Observation process across formations             #
    #                                                           #
    #############################################################
    
    
    
        # Priors for detection probability
        
        ### temperature effect on detection
        for (l in 1:nlith) {
        
          for (g in 1:ngen) {
           
             alpha.p[l,g] ~ dunif(0,1)
             intercept.p[l,g] <- logit(alpha.p[l,g])
             
          }
        }
        
        # temp effect
        for (g in 1:ngen) {
          
          alpha1.temp[g] ~ dnorm(0, 0.001)
           
        } 

     ############      Model       #############
     
     
      # Observation model for replicated counts
      for (k in 1:nobs) { # Loop over all n observations
        
          y[k] ~ dbin(z[site[k],int[k],gen[k]]*p[k], nsurvey[k])
          logit(p[k])<- intercept.p[lith[k],gen[k]]+ 
                                      alpha1.temp[gen[k]]*tempObs[k] 
      
      }
    
    # -----------------------------------------------
    
    ## derived parameters
    # number of gen per interval
    for (t in 1:nint) {
        Ngen[t]<-sum(z[,t,])
    }
    
    ## number of genera per site
    for (i in 1:nsites) {
        Ngen_site[i]<-sum(z[i,,])
    }
    

    ## average persistence and origination
   #for (g in 1:ngen) {
   #  avphi[g] <- mean(phi[,2:nint,g])
   #  avgamma[g]<- mean(gamma[,2:nint,g])
   #}
   #
   ### turnover (proportional gain or loss)
   #for (t in 2:nint) {  
   #  
   #    propcH [t] <-(sum(z[,t,])-sum (z[,t-1,]))/sum(z[,t-1,]) 
   #  
   #}
    
    ## equilibrium occupancy (which gen decline or increase over time)
    #for (g in 1:ngen) {
    #
    #    psi.eq[g] <- mean(gamma[2:nint,g])/(mean(gamma[2:nint,g])+mean(1-phi[2:nint,g])) # Equilibrium occupancy
    #    #psi.eq[g] <- gamma[g]/(gamma[g]+(1-phi[g])) # Equilibrium occupancy
    #}
    #
    ## relative extinction rate (μ/λ; Rabosky 2018) of each time
    #for (t in 2:nint) { 
    # for (g in 1:ngen) {
    #
    #    #RER[g] <- (1-phi[g])/gamma[g]
    #    RER[t,g] <- (1-phi[t,g])/gamma[t,g]
    #
    #  }
	  #}
    #
    ## net diversification rate (r= μ - λ; Rabosky 2018) of each time
    #for (t in 2:nint) { 
    # for (g in 1:ngen) {
    #
    #    #R0[g] <- (1-phi[g])-gamma[g]
    #    R0[t,g] <- (1-phi[t,g])-gamma[t,g]
    #
     #}
    #}
    
        
    }## end of the model
    
    
    

    
    
